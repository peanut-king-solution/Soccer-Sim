{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to RCJ Soccer Sim!","text":"<p>This is the official repository of the RoboCupJunior Soccer Simulator. The simulator is based on Webots and this repository provides both the \"automatic referee\" (which implements the Soccer Simulated Rules) as well as a sample simulated team of robots with some basic strategy.</p> <p></p>"},{"location":"#how-do-i-try-this-out","title":"How do I try this out?","text":"<p>Setting up is easy:</p> <ul> <li>Getting started</li> <li>How to program your robot</li> <li>How to communicate between robots</li> <li>How to run the simulation</li> </ul> <p>Please do not hesitate to ask any questions on the forum.</p>"},{"location":"communication_between_robots/","title":"Communication between robots","text":"<p>Each of the robots is equipped with two Receivers and one Emitter. One of the Receivers is used for receiving data from Supervisor. The Emitter and the second Receiver can be used for sending and receiving data between robots from the same team. We are going to describe what needs to be done in order to make use of it.</p>"},{"location":"communication_between_robots/#definition-in-the-world-file","title":"Definition in the world file","text":"<p>Our world file defines one Emitter and one Receiver for team communication for each robot. Blue team is assigned channel 2, while yellow team is assigned channel 3. Webots supports changing channels, but we turned this feature off so teams are not able to spam the opponent with a bunch of messages. The name of the Emitter is set to <code>team emitter</code>, while the Receiver can be found under name <code>team receiver</code>.</p>"},{"location":"communication_between_robots/#initializing-the-communication","title":"Initializing the communication","text":"<p>The first thing we need to do in order to setup the communication is initialize the Emitter and Receiver. To do so, just call following commands. We are going to use the OOP approach here as well (see our sample robot controllers).</p> <pre><code>self.team_emitter = self.robot.getDevice(\"team emitter\")\nself.team_receiver = self.robot.getDevice(\"team receiver\")\nself.team_receiver.enable(TIME_STEP)\n</code></pre> <p>Before using the Receiver, we must enable it with <code>enable(TIME_STEP)</code> command, where <code>TIME_STEP</code> is the same value we use in our controller when calling <code>self.robot.step(TIME_STEP)</code>.</p>"},{"location":"communication_between_robots/#sending-a-message","title":"Sending a message","text":"<p>Each time we send a message via a channel, all the receivers listening on this channel are going to receive it. So, if <code>robot1</code> sends a message, <code>robot2</code> and <code>robot3</code> from the same team can read it.</p>"},{"location":"communication_between_robots/#converting-the-message-into-a-packet","title":"Converting the message into a packet","text":"<p>Imagine we would like to send values <code>v1</code>, <code>v2</code>, ... , <code>vn</code>. Before the message is sent to the channel, it must be converted into a packet. Simply put, the packet is just a bytes object representing values <code>v1</code>, <code>v2</code>, ... , <code>vn</code>. To convert our values into bytes object we can use built-in library called struct, which is shipped together with Python.</p> <p>We need to know the type of each value we want to pack into a packet. Let's see a quick example. The values we want to send are <code>v1 = 3.14</code>, <code>v2 = 5</code> and <code>v3 = True</code>. It is obvious that <code>v1</code> is floating point number, <code>v2</code> is integer and <code>v3</code> is boolean. Knowing the type of each variable, we need to define the structure of the message.</p> <pre><code>message_format = \"di?\"\n</code></pre> <p>The <code>struct</code> library defines various symbols we might use in order to represent a variable type. In our example <code>\"d\"</code> is representing floating point number, <code>\"i\"</code> is representing integer and <code>\"?\"</code> is representing boolean value. If you want to use other variable types, check out the struct format characters documentation. Since we now know the structure of the message, we can create the packet</p> <pre><code>packet = struct.pack(message_format, v1, v2, v3)\n</code></pre> <p>Keep in mind that the order of variables passed to <code>pack()</code> function MUST be in the same order as specified in <code>message_format</code>, otherwise you might get a broken packet.</p> <p>The only thing we need to do is emit the packet by the Emitter. It is as easy as just calling </p> <pre><code>self.team_emitter.send(packet)\n</code></pre> <p>and the message is succesfully sent to the channel.</p>"},{"location":"communication_between_robots/#receiving-a-message","title":"Receiving a message","text":"<p>When a Receiver receives a message, it adds it to the queue. We are then able to pull the oldest message out of the queue.</p> <p>To check the number of messages waiting in the queue, we can call</p> <pre><code>self.team_receiver.getQueueLength()\n</code></pre> <p>If the there are new messages, the number of messages will be greater than 0 and we can proceed with reading the message.</p> <pre><code>packet = self.team_receiver.getBytes()\nself.team_receiver.nextPacket()\n</code></pre> <p>In the first row we call the <code>getBytes()</code> method, which returns the packet and assigns it to the <code>packet</code> variable. The <code>nextPacket()</code> method is used to move the pointer to the next packet in the queue, so next time we are calling <code>getBytes()</code>, we are going to read next packet in the queue.</p> <p>Okay, now we have packet. How do we unpack it? Well, remember our cool <code>struct</code> library? We are going to use it for unpacking the packet, too.</p> <p>First of all, we need to know what data we expect. In our example, we sent three variables in this order - floating point number, integer and boolean. Therefore, we can define the format of the message here as well.</p> <pre><code>message_format = 'di?'\n</code></pre> <p>Knowing what data to expect, we can unpack the packet by following command:</p> <pre><code>unpacked = struct.unpack(message_format, packet)\n</code></pre> <p>The variable <code>unpacked</code> is a tuple with our values. If we print it, we will get <code>(3.14, 5, True)</code>. We can access the values as we would for list (or array in other languages)</p> <pre><code>v1 = unpacked[0]\nv2 = unpacked[1]\nv3 = unpacked[2]\n</code></pre> <p>WARNING: There are 3 robots within the team running asynchronously. If all of them are sending messages, it is always good to empty the queue before moving on, otherwise the queue might grow and you will be reading old messages. You can use a <code>while</code> loop for example</p> <pre><code>while self.team_receiver.getQueueLength() &gt; 0:\n    packet = self.team_receiver.getBytes()\n    self.team_receiver.nextPacket()\n    # Do something with the packet\n</code></pre>"},{"location":"getting_started/","title":"How do I try this out?","text":"<p>It's easy, you can set it up in about 10 minutes! (plus download time)</p>"},{"location":"getting_started/#installation","title":"Installation","text":"<ol> <li> <p>Install Python 3.7 (or higher) 64 bit from the official website (please make sure it is version 3.7 or higher for Windows, and 3.8 or higher if installing on MacOS or Linux). On Windows, please make sure your Python is referenced in Windows PATH by selecting the option \"Add Python 3.x to PATH\" during the installation. Check out this great installation guide if you need some help!</p> </li> <li> <p>Download Webots from their official website. Currently, version R2022a is stable with the Soccer Simulator. You can find detailed installation procedure on the official Webots Installation guide.</p> </li> <li> <p>Clone the rcj-soccersim repository to your computer by downloading the ZIP file from here or running</p> <pre><code>git clone https://github.com/RoboCupJuniorTC/rcj-soccersim.git\n</code></pre> </li> <li> <p>Finally, run Webots, go to <code>Tools &gt; Preferences &gt; Python command</code> and set it to <code>python</code> or <code>python3</code> to point Webots to Python 3. Depending on your system, the reference to Python 3 can be via the command <code>python</code> or <code>python3</code>. More information on how to configure Webots to work with Python can be found here.</p> </li> </ol>"},{"location":"getting_started/#running-soccer-sim","title":"Running Soccer Sim","text":"<ol> <li> <p>Use Webots to open the downloaded <code>soccer.wbt</code> world located in the <code>worlds</code>    directory (via <code>File &gt; Open World</code>)</p> </li> <li> <p>Run/pause the simulation by clicking the corresponding buttons on the top-part of Webots window. Note that the controllers that are responsible for the    various robots on the field can be found in the <code>controllers/</code> directory.</p> </li> </ol>"},{"location":"getting_started/#notes","title":"Notes","text":"<p>A specific <code>webots</code> world can be executed directly from the command line as follows:</p> <pre><code>    webots --mode=run worlds/soccer.wbt\n</code></pre> <p>Which allows for at least some automation. Further info can be found in the docs.</p> <p>The sample players as well as the \"automatic referee\" are implemented in Python, which should allow for easily updating the code to match the rules and avoid any compilation issues.</p>"},{"location":"how_to_robot/","title":"How to program your robot","text":""},{"location":"how_to_robot/#controllers","title":"Controllers","text":"<p>Each object in the simulation world can be controlled by a program. This program is called Controller. Each robot should have exactly one controller, implemented as a Python3 program. There is an invisible referee object in the simulation, which takes care of controlling the game and checking the rules.</p> <p>The controllers are located in the <code>controllers</code> directory. The name of the controller must be located in a subfolder with the same name (i.e. <code>robot/robot.py</code>) and this name ought to be specified in <code>soccer.wbt</code> file.</p>"},{"location":"how_to_robot/#hello-world-robot","title":"Hello world, robot!","text":"<p>We have prepared a few sample robot controllers. They can be found in the <code>controllers</code> directory. The controllers for the robots of blue team are located in <code>rcj_soccer_team_blue</code> folder and for the robots of yellow team in <code>rcj_soccer_team_yellow</code> folder, respectively.</p> <p>Team folders contain a file called <code>rcj_soccer_team_blue.py</code> (blue team) or <code>rcj_soccer_team_yellow.py</code> (yellow team). Each of the robots initially runs this file (for the competition, it should be <code>robot.py</code>). Based on the unique identifier of the robot (which can be <code>1</code>, <code>2</code> or <code>3</code>) we initialize the code for the particular robot.</p>"},{"location":"how_to_robot/#script-for-determining-and-initializing-the-robot-controller","title":"Script for determining and initializing the robot controller","text":"<p>A sample initial file might look as follows:</p> <pre><code>from controller import Robot\n\nfrom robot1 import MyRobot1\nfrom robot2 import MyRobot2\nfrom robot3 import MyRobot3\n\n\nrobot = Robot()\nname = robot.getName()\nrobot_number = int(name[1])\n\nif robot_number == 1:\n    robot_controller = MyRobot1(robot)\nelif robot_number == 2:\n    robot_controller = MyRobot2(robot)\nelse:\n    robot_controller = MyRobot3(robot)\n\nrobot_controller.run()\n</code></pre> <p>Let's describe a file for determining robot's name and running specific controller.</p> <pre><code>from controller import Robot\n</code></pre> <p>The Robot class is required to be imported because this is the only way we are able to controll the robot. The Robot class is shipped together with Webots.</p> <pre><code>from robot1 import MyRobot1\nfrom robot2 import MyRobot2\nfrom robot3 import MyRobot3\n</code></pre> <p>Since all of robot controllers are located in the same directory, we can easily import them.</p> <pre><code>robot = Robot()\nname = robot.getName()\n</code></pre> <p>Initialize robot instance and get the name of the robot. The name is one of the following <code>{\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"}</code>.</p> <pre><code>robot_number = int(name[1])\nif robot_number == 1:\n    robot_controller = MyRobot1(robot)\nelif robot_number == 2:\n    robot_controller = MyRobot2(robot)\nelse:\n    robot_controller = MyRobot3(robot)\n</code></pre> <p>By checking the second character in the name, we can easily get the number identifier of the robot and initialize its controller appropriately.</p> <pre><code>robot_controller.run()\n</code></pre> <p>We just call the method <code>run</code> in order to execute the code for the specific robot we initialized previously.</p>"},{"location":"how_to_robot/#robot-controller","title":"Robot controller","text":"<p>Let's put together a simple program to showcase how you can go about programming a robot.</p> <pre><code>import struct\n\nTIME_STEP = 32\nROBOT_NAMES = [\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"]\nN_ROBOTS = len(ROBOT_NAMES)\n\n\nclass MyRobot:\n    def __init__(self, robot):\n        self.robot = robot\n        self.name = self.robot.getName()\n\n        self.receiver = self.robot.getDevice(\"supervisor receiver\")\n        self.receiver.enable(TIME_STEP)\n\n        self.ball_receiver = self.robot.getDevice(\"ball receiver\")\n        self.ball_receiver.enable(TIME_STEP)\n\n        self.gps = self.robot.getDevice(\"gps\")\n        self.gps.enable(TIME_STEP)\n\n        self.compass = self.robot.getDevice(\"compass\")\n        self.compass.enable(TIME_STEP)\n\n        self.sonar_left = self.robot.getDevice(\"distancesensor left\")\n        self.sonar_left.enable(TIME_STEP)\n        self.sonar_right = self.robot.getDevice(\"distancesensor right\")\n        self.sonar_right.enable(TIME_STEP)\n        self.sonar_front = self.robot.getDevice(\"distancesensor front\")\n        self.sonar_front.enable(TIME_STEP)\n        self.sonar_back = self.robot.getDevice(\"distancesensor back\")\n        self.sonar_back.enable(TIME_STEP)\n\n        self.left_motor = self.robot.getDevice(\"left wheel motor\")\n        self.right_motor = self.robot.getDevice(\"right wheel motor\")\n\n        self.left_motor.setPosition(float('+inf'))\n        self.right_motor.setPosition(float('+inf'))\n\n        self.left_motor.setVelocity(0.0)\n        self.right_motor.setVelocity(0.0)\n\n    def get_new_data(self):\n        packet = self.receiver.getBytes()\n        self.receiver.nextPacket()\n\n        struct_fmt = '?'\n\n        unpacked = struct.unpack(struct_fmt, bytes(packet))\n        data = {\n            \"waiting_for_kickoff\": unpacked[0]\n        }\n        return data\n\n    def run(self):\n        while self.robot.step(TIME_STEP) != -1:\n            if self.receiver.getQueueLength() &gt; 0:\n                data = self.get_new_data()\n\n                # Get data from compass\n                heading = self.get_compass_heading()\n\n                # Get GPS coordinates of the robot\n                robot_pos = self.get_gps_coordinates()\n\n                # Get data from sonars\n                sonar_values = self.get_sonar_values()\n\n                # Get direction and strength of the IR signal\n                if self.is_new_ball_data():\n                    ball_data = self.get_new_ball_data()\n\n                self.left_motor.setVelocity(1)\n                self.right_motor.setVelocity(-1)\n</code></pre> <p>Let's explain the code in detail:</p> <pre><code>import struct\n</code></pre> <p>This library is a built-in Python library, which is required to unpack the data sent by the supervisor.</p> <pre><code>TIME_STEP = 32\nROBOT_NAMES = [\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"]\nN_ROBOTS = len(ROBOT_NAMES)\n</code></pre> <p>We also define some useful constants, whose values will be used later.</p> <pre><code>class MyRobot:\n</code></pre> <p>You can wrap the program into the class as we did. The benefit of OOP (Object Oriented Programming) is that you can later reuse the same common class throughout your controllers and therefore make the code easier to read. We are going to continue with our OOP approach.</p> <pre><code>def __init__(self, robot):\n    self.robot = robot\n    self.name = self.robot.getName()\n    ...\n</code></pre> <p>The <code>__init__</code> function is something like a constructor of the class and is called when an instance of the <code>MyRobot</code> object is created. We use this function to initialize some important variables. The most important one is the <code>Robot</code> instance, which allows us to get access to the so called Webots devices like motor (for controlling the speed), receiver (for reading data from Supervisor), and sensors like GPS, Compass, Sonars or IR Ball receiver. The name and the team of your robot can be determined by calling <code>self.robot.getName()</code>. It will give you one of <code>{\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"}</code>. The first letter determines the team (\"Blue\", \"Yellow\"), while the second one is the robot's identifier. If you want to know the side of your team (either \"Blue\" or \"Yellow\"), you can find out by checking <code>self.name[0]</code>, which essentially gives you <code>\"B\"</code> for Blue or <code>\"Y\"</code> for Yellow side.</p> <pre><code>def get_new_data(self):\n    ...\n</code></pre> <p>We are not going to explain this deeply. This function simply parses the incoming data from supervisor. Feel free to copy and use it. The resulting dictionary just contains a single bit of information: whether a goal was scored and we are waiting for a new kickoff. In case the goal gets scored, the value is <code>True</code> and is reset to <code>False</code> when the referee fires new kickoff.</p> <pre><code>def run(self):\n</code></pre> <p>This is the method which contains the logic for controlling the robot. As mentioned previously, it is called by our initialization script.</p> <pre><code>while self.robot.step(TIME_STEP) != -1:\n</code></pre> <p>The <code>step</code> function is crucial and must be used in every controller. This function synchronizes the sensor and actuator data between Webots and the controllers.</p> <pre><code>if self.receiver.getQueueLength() &gt; 0:\n</code></pre> <p>Before reading data, it is important to check if there is actually something in the queue that we can read.</p> <pre><code>data = self.get_new_data()\n\nheading = self.get_compass_heading()\nrobot_pos = self.get_gps_coordinates()\nsonar_values = self.get_sonar_values()\nif self.is_new_ball_data():\n    ball_data = self.get_new_ball_data()\n\nself.left_motor.setVelocity(1)\nself.right_motor.setVelocity(-1)\n</code></pre> <p>And finally, after reading the new data received from supervisor as well as data from sensors we do some calculations and set the speed of the motors.</p>"},{"location":"how_to_robot/#available-sensors","title":"Available sensors","text":""},{"location":"how_to_robot/#gps","title":"GPS","text":"<p>This sensor gives you the exact position of the robot. For more information check official GPS documentation. In <code>rcj_soccer_robot.py</code> you can find <code>get_gps_coordinates()</code>, which demonstrates how to work with GPS sensor.</p>"},{"location":"how_to_robot/#compass","title":"Compass","text":"<p>Useful sensor to determine the angle (rotation) of the robot from the north. For more information check official compass documentation. In <code>rcj_soccer_robot.py</code> you can find <code>get_compass_heading()</code>, which demonstrates how to work with compass sensor.</p>"},{"location":"how_to_robot/#sonars","title":"Sonars","text":"<p>There are four sonars mounted on the robot (each side having one). Since the exact position of the robot may be retrieved from GPS, these sensors are useful for detecting the opponent's robots. For more information check official distance sensor documentation.</p> <p>Note that you may encounter some error in measurements. When the robot is next to an obstacle, the value returned is 0 with error of 0%. On the other hand, when the sesnsor does not see anything, the value returned is 1000 with error of 5%. The values and errors in between are linearly interpolated.</p> <p>In <code>rcj_soccer_robot.py</code> you can find <code>get_sonar_values()</code>, which demonstrates how to work with sonar sensors. For debugging purposes, you may find it useful to turn on rendering rays of distance sensors. This option is available in Webots GUI under <code>View -&gt; Optional Rendering -&gt; Show DistanceSensor Rays</code>.</p>"},{"location":"how_to_robot/#ball-ir-sensor","title":"Ball IR Sensor","text":"<p>There is an infra-red emitter mounted onto the ball. The emitter just emits a signal and each robot receives this signal if it is located within a pre-defined range. The receiver is able to determine the direction as well as strength of the signal, which can be used for navigating robots towards the ball.</p> <p>For more information check the official receiver documentation or our <code>get_new_ball_data()</code> method in <code>rcj_soccer_robot.py</code>.</p>"},{"location":"how_to_robot/#importing-shared-code","title":"Importing shared code","text":"<p>Each team consists of three robots. These robots might share some of the code and it is  actually a good practice not to duplicate code all over the place.</p> <p>Imagine you have the folder structure which looks like this</p> <pre><code>controllers/\n\u251c\u2500\u2500 robot/\n\u2502   \u2514\u2500\u2500 robot.py\n\u2502   \u2514\u2500\u2500 robot1.py\n\u2502   \u2514\u2500\u2500 robot2.py\n\u2502   \u2514\u2500\u2500 robot3.py\n|   \u2514\u2500\u2500 utils.py\n</code></pre> <p>and within <code>robot1.py</code>, <code>robot2.py</code> and <code>robot3.py</code> you want to import some useful code from <code>utils.py</code>. You can easily import it by calling</p> <pre><code>import utils\n</code></pre> <p>and use the shared code rather than copying it into each of the controllers. Do not import anything from <code>robot.py</code> file, otherwise you might get cyclic import problem.</p>"},{"location":"how_to_robot/#supported-external-libraries","title":"Supported external libraries","text":"<p>In general, the whole Python's standard library can be used in the robot's programs.</p> <p>Furthermore, to make the computations easier, the Soccer Sim environment supports the following two Python libraries that are normally used for what's called \"scientific computing\":</p> <ul> <li><code>numpy</code> (version 1.20.2)</li> <li><code>scipy</code> (version 1.6.3)</li> </ul>"},{"location":"how_to_run_sim/","title":"Running the simulator","text":"<p>Note: This document is intended for the organizers of events in which the RCJ Soccer Sim is to be used</p> <p>This document outlines how the RoboCupJunior Soccer Sim can be used to simulate a match in a \"headless\" way. In other words, it shows how you can go from having the code for two teams and the RoboCupJunior Soccer Sim code to getting an output in form of either an MPEG-4 video or a HTML site.</p> <p>Input</p> <ul> <li>Source code for the yellow team</li> <li>Source code for the blue team</li> <li>RoboCupJunior Soccer Sim</li> </ul> <p>Output</p> <ul> <li>MPEG-4 video and/or HTML site</li> <li>JSON file containing all the important events happened during the game</li> </ul>"},{"location":"how_to_run_sim/#preliminaries","title":"Preliminaries","text":"<p>This guide makes a couple of assumptions:</p> <ol> <li>You use an UNIX-like environment (i.e. something like Linux or macOS)</li> <li>You have Webots installed and cloned the <code>rcj-soccersim</code> repository locally    (check the Getting Started guide on how to do so)</li> </ol>"},{"location":"how_to_run_sim/#running-soccer-sim-and-webots-in-automatic-mode","title":"Running Soccer Sim (and Webots) in Automatic Mode","text":"<p>As Webots docs state, it can also be started from a Terminal, or a command line prompt. The most basic command would look as follows:</p> <pre><code>webots --mode=fast worlds/soccer.wbt\n</code></pre> <p>This opens up Webots and automatically starts the game in the GUI. You can then either pause the game, restart it or even manually setup the video/HTML export.</p> <p>Soccer Sim's referee has the ability to automatically start the recording and stop the execution when it finishes. To do so, the <code>RCJ_SIM_AUTO_MODE</code> environment variable needs to be set (the value doesn't matter but we suggest <code>True</code> or something of that sort). Furthermore, to make sure the game is recorded, a recording format needs to be specified. This is done via the <code>RCJ_SIM_REC_FORMATS</code> environment variable and all the options are documented in the section below.</p> <p>In summary, to automatically run the <code>world/soccer.wbt</code> world file (the Soccer environment) and record the output in HTML format, the following command can be used:</p> <pre><code>RCJ_SIM_AUTO_MODE=True RCJ_SIM_REC_FORMATS=x3d webots --mode=fast worlds/soccer.wbt\n</code></pre>"},{"location":"how_to_run_sim/#running-soccer-sim-in-docker","title":"Running Soccer Sim in Docker","text":"<p>To simplify the automatic running of games, Soccer Sim can also be executed inside a Docker container. We generally recommend using the offical container provided by Webots and mentioned in the official guide.</p> <p>Assuming the <code>rcj-soccersim</code> repository is located in the current directory, running Soccer Sim within docker is as simple as executing</p> <pre><code>docker run \\\n    -v $(pwd)/rcj-soccersim:/rcj-soccersim \\\n    -e RCJ_SIM_AUTO_MODE=True \\\n    -e RCJ_SIM_REC_FORMATS=x3d \\\n    cyberbotics/webots:latest /rcj-soccersim/run-in-docker.sh /rcj-soccersim/worlds/soccer.wbt\n</code></pre> <p>Let us briefly discuss the respective lines. On the first one the <code>docker</code> command starts the Docker container, on the second one, the <code>rcj-soccersim</code> folder in the current directory is mapped to <code>/rcj-soccersim</code> in the container, on the following two the <code>RCJ_SIM_AUTO_MODE</code> and <code>RCJ_SIM_REC_FORMATS</code> environment variables are being set and on the last one the <code>worlds/soccer.wbt</code> world from the <code>rcj-soccersim</code> repository is executed in the Webex environment using the <code>run-in-docker.sh</code> script (also part of the very same repository).</p>"},{"location":"how_to_run_sim/#extracting-the-recorded-output","title":"Extracting the recorded output","text":"<p>By default, the output (recording and reflog) of a match is saved in the <code>reflog/</code> folder in <code>controllers/rcj_soccer_referee_supervisor/</code> of the <code>rcj-soccersim</code> repository. This is relatively inconveniet when it comes to running multiple games and getting data out of the Docker container and hence the path can be changed using the <code>RCJ_SIM_OUTPUT_PATH</code> environment variable.</p> <p>The command below redirects the output to the <code>/tmp/outputs</code> directory inside the container and maps it to the <code>outputs/</code> directory in the current working directory on the host:</p> <pre><code>docker run \\\n    -v $(pwd)/rcj-soccersim:/rcj-soccersim \\\n    -v $(pwd)/outputs:/tmp/outputs  \\\n    -e RCJ_SIM_AUTO_MODE=True \\\n    -e RCJ_SIM_REC_FORMATS=x3d \\\n    -e RCJ_SIM_OUTPUT_PATH=/tmp/outputs/ \\\n    cyberbotics/webots:latest /rcj-soccersim/run-in-docker.sh /rcj-soccersim/worlds/soccer.wbt\n</code></pre>"},{"location":"how_to_run_sim/#environment-variables","title":"Environment variables","text":"<p>The full list of environment variables supported by the Soccer Sim can be found below:</p> <ul> <li><code>RCJ_SIM_AUTO_MODE</code>: If set (to any value), the simulation speed is set to     fast, the recorders are started at the beginning and the application is     automatically closed after the match is finished. Not set by default.</li> <li><code>RCJ_SIM_MATCH_TIME</code>: Sets the number of seconds for which the match is to be     played. Defaults to 600 (10 minutes).</li> <li><code>RCJ_SIM_REC_FORMATS</code>: When set, the Soccer Sim starts a recording in these     formats. The available options are <code>mp4</code> and <code>x3d</code>. Multiple options can be     set as well, separated by a comma. Not set by default.</li> <li><code>RCJ_SIM_OUTPUT_PATH</code>: The path where the reflog outputs as well as the     recordings are to be saved. Defaults to the <code>reflog/</code> folder in     <code>controllers/rcj_soccer_referee_supervisor/</code>.</li> </ul> <p>Internal team-related variables:</p> <ul> <li><code>RCJ_SIM_TEAM_YELLOW_NAME</code>: The name of the yellow team. Defaults to \"The Yellows\".</li> <li><code>RCJ_SIM_TEAM_Y_INITIAL_SCORE</code>: The initial score of the yellow team. Defaults to 0.</li> <li><code>RCJ_SIM_TEAM_BLUE_NAME</code>: The name of the blue team. Defaults to \"The Blues\".</li> <li> <p><code>RCJ_SIM_TEAM_B_INITIAL_SCORE</code>: The initial score of the blue team. Defaults to 0.</p> </li> <li> <p><code>RCJ_SIM_TEAM_YELLOW_ID</code>: The ID of the yellow team used for internal identification.     Defaults to \"The Yellows\".</p> </li> <li><code>RCJ_SIM_TEAM_BLUE_ID</code>: The ID of the yellow team used for internal identification.     Defaults to \"The Blues\".</li> <li><code>RCJ_SIM_MATCH_ID</code>: The ID of the match used for internal identification.     Defaults to 1.</li> <li><code>RCJ_SIM_HALF_ID</code>: The ID of the half time used for internal identification.     Defaults to 1.</li> </ul>"}]}